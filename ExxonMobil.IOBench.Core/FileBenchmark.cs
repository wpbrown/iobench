// Copyright 2014 ExxonMobil Technical Computing Company
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Runtime.InteropServices;
using System.ComponentModel;
using Microsoft.Win32.SafeHandles;
using ExxonMobil.Shared.Win32;

namespace ExxonMobil.IOBench.Core
{
    public class FileBenchmark : Benchmark
    {
		public FileBenchmark(BenchmarkConfiguration config, bool enablePerfmon = true) :
			base(config, enablePerfmon)
		{
		}

        protected override void Run()
        {
			if (config.FilePerBlock)
				MultiFileRun();
			else
				SingleFileRun();
        }

		private unsafe void MultiFileRun()
		{
			PreMultiFileRun();

            wallTime.Start();
			for (int i = 0; i < config.Blocks; i++)
			{
				if (status.Canceled)
					return; 

				var filePath = String.Format("{0}.{1:0000000}", config.FilePath, i);
				RunTransfer(filePath, 1);
			}
            wallTime.Stop();
		}

		private void PreMultiFileRun()
		{
			var files =
				Directory.EnumerateFiles(Path.GetDirectoryName(config.FilePath), Path.GetFileName(config.FilePath) + ".???????")
				.Where(s =>
				{
					int index;
					return int.TryParse(s.Substring(s.Length - 7), out index) && index < config.Blocks;
				});
			if (config.IsWrite)
			{
				foreach (var file in files)
					File.Delete(file);
			}
			else if (config.IsRead)
			{
				if (files.Count() < config.Blocks)
					throw new BenchmarkException("One of the files in the multi-file sequence was not found.")
					{
						HelpText = "The read operation should be run on a sequence of files with the specified path " +
							"with .0000000 pattern appended. These files can be generated by a multi-file write benchmark."
					};
			}
		}

		private void SingleFileRun()
		{
			PreSingleFileRun();
            wallTime.Start();
			RunTransfer(config.FilePath, config.Blocks);
            wallTime.Stop();
		}

		unsafe private void RunTransfer(string path, int blocks)
		{
			using (var fileHandle = CreateFile(path))
			{
				if (config.IsWrite)
				{
					preallocTime.Start();
					try
					{
						NativeCore.SetFileSize(fileHandle, config.FileSizeBytes);
						if (config.Preallocation == PreallocationType.Zeroed)
							NativeCore.PreallocateZerod(fileHandle, config.FileSizeBytes, config.Asynchronous);
						else if (config.Preallocation == PreallocationType.Unzeroed)
							NativeCore.PreallocateUnzerod(fileHandle, config.FileSizeBytes);
					}
					finally
					{
						preallocTime.Stop();
					}
				}
				else //config.IsRead == TRUE
				{
					long fileSize;
					Win32Methods.GetFileSizeEx(fileHandle, out fileSize);
					if (fileSize < config.FileSizeBytes)
						throw new BenchmarkException("The file '" + config.FilePath + "' is not large enough for this read operation.");
				}

				transferTime.Start();
				try
				{
					fixed (void* ptr = &status)
					{
						bool retVal;
						IntPtr pStatus = new IntPtr(ptr);
						var randomData = config.WriteDataType == WriteDataType.Random;
						if (config.Asynchronous)
							retVal = NativeCore.AsynchronousOp(fileHandle, config.Operation, config.AccessPattern, config.ReadVerify, blocks, config.BlockSizeBytes, randomData, config.AsyncMaxBlocksOutstanding, pStatus);
						else
							retVal = NativeCore.SynchronousOp(fileHandle, config.Operation, config.AccessPattern, config.ReadVerify, blocks, config.BlockSizeBytes, randomData, pStatus);
						if (!retVal)
							NativeCore.ThrowException();
					}

					if (config.Operation == BenchmarkOperation.Write && !config.DontFlushBuffers)
					{
						if (!Win32Methods.FlushFileBuffers(fileHandle))
							throw new Win32Exception();
					}
				}
				finally
				{
					transferTime.Stop();
				}
			}
		}

		private void PreSingleFileRun()
		{
			if (config.IsWrite && File.Exists(config.FilePath))
				File.Delete(config.FilePath);
			else if (config.IsRead && !File.Exists(config.FilePath))
				throw new BenchmarkException("File to read not found.");
		}
    }
}
